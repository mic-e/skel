#!/usr/bin/env python3
import argparse
import collections
import os


class InstException(Exception):
    pass


def parse_args():
    pars = argparse.ArgumentParser(description="skel installer")
    mode = pars.add_mutually_exclusive_group()
    mode.add_argument("--symlink", action="store_true",
                      help="Instead of copying the files, symlink them")
    mode.add_argument("--hardlink", action="store_true",
                      help="Instead of copying the files, hardlink them")
    pars.add_argument("--to-etc-skel", action="store_true",
                      help="Instead of ~, install to /etc/skel")
    pars.add_argument("--force-unchanged-files", action="store_true",
                      help="re-install files even if they didn't change")
    pars.add_argument("--backup", type=str, default=None,
                      help="backup all overwritten files to this tar file")
    pars.add_argument("--simulate", action="store_true",
                      help="don't do anything, just print the commands")
    pars.add_argument("skeldir", nargs="+",
                      help="Source directory for installation")

    return pars.parse_args()


def main():
    args = parse_args()
    if args.to_etc_skel:
        tgtdir = "/etc/skel"
    else:
        tgtdir = os.environ["HOME"]

    # lists of file actions to perform
    mkdirlist = []
    installlist = []
    dupeinstalls = {}
    warnings = []
    overwritten_tgtfiles = []

    # scan skeldir, check for actions to perform (fill mkdirlist, installlist)
    for skeldir in args.skeldir:
        if not os.path.isdir(skeldir):
            raise InstException("not a directory: " + skeldir)

        searchqueue = collections.deque([(skeldir, tgtdir)])

        while len(searchqueue) > 0:
            srcdirname, tgtdirname = searchqueue.pop()

            for f in sorted(os.listdir(srcdirname)):
                srcfile = srcdirname + "/" + f
                tgtfile = tgtdirname + "/" + f

                if os.path.islink(srcfile):
                    raise InstException("symlink: " + srcfile)

                if os.path.isdir(srcfile):
                    # it's a dir, so we need to create that if not exists
                    if os.path.exists(tgtfile):
                        if os.path.isdir(tgtfile):
                            # dir already exists, everything's fine
                            pass
                        else:
                            # there is a file with that name
                            raise InstException("Existing file " + tgtfile +
                                                " blocks directory creation")
                    else:
                        # we need to create the dir
                        if tgtfile not in mkdirlist:
                            mkdirlist.append(tgtfile)

                    # recursively search that dir, too
                    searchqueue.appendleft((srcfile, tgtfile))

                else:
                    # it's a file, so we need to copy it
                    if os.path.exists(tgtfile):
                        if os.path.isdir(tgtfile):
                            raise InstException("Existing dir " + tgtfile +
                                                " prevents file installation")

                        if not args.force_unchanged_files:
                            # check whether the file differs
                            tgtdata = open(tgtfile, 'rb').read()
                            srcdata = open(srcfile, 'rb').read()
                            if tgtdata == srcdata:
                                continue

                        exists = True
                    else:
                        exists = False

                    if tgtfile in dupeinstalls:
                        warnings.append(tgtfile + " from \x1b[1m" +
                                        dupeinstalls[tgtfile] + "\x1b[m " +
                                        "obsolted by \x1b[1m" + skeldir +
                                        "\x1b[m")

                        installlist = [entry for entry in installlist if
                                       entry[1] != tgtfile]

                    dupeinstalls[tgtfile] = skeldir

                    installlist.append((srcfile, tgtfile, exists, skeldir))

    if not installlist and not mkdirlist:
        raise InstException("Nothing to be installed")

    # ask for user confirmation
    if mkdirlist:
        print("The following directories will be created:\n")
        for tgtfile in mkdirlist:
            print("\x1b[3m" + tgtfile + "\x1b[m")

        print("")

    if installlist:
        print("The following files will be installed:\n")
        maxtgtfilelen = len(max(installlist, key=lambda x: len(x[1]))[1])
        maxskeldirlen = len(max(installlist, key=lambda x: len(x[3]))[3])

        for _, tgtfile, exists, skeldir in installlist:
            if exists:
                if args.backup:
                    warning = "\x1b[33m[File will be backed up]\x1b[m"
                else:
                    warning = "\x1b[31;1m[File will be overwritten]\x1b[m"

                overwritten_tgtfiles.append(tgtfile)
            else:
                warning = ""

            print(tgtfile.ljust(maxtgtfilelen) + " from \x1b[1m" +
                  skeldir.ljust(maxskeldirlen) + "\x1b[m " + warning)

        print("")

    if args.backup and not overwritten_tgtfiles:
        warnings.append("nothing to backup")
        args.backup = False
    elif not args.backup and overwritten_tgtfiles:
        warnings.append("files will be overwritten, " +
                        "but no backup will be performed!")

    if args.simulate:
        warnings.append("simulation run: none of these actions will actually "
                        "be performed.")
        if args.backup:
            warnings.append("this includes your backup!")

    if warnings:
        print("\x1b[1;33m[Warnings]\x1b[m\n")
        for warning in warnings:
            print(warning)

        print("")

        prompt = "Continue [y/N]? "
        accepted_answers = {"Y", "y"}
    else:
        prompt = "Continue [Y/n]? "
        accepted_answers = {"Y", "y", ""}

    if input(prompt) not in accepted_answers:
        raise InstException("Aborted by user")

    print("")

    # create backup
    if args.backup:
        print("\x1b[1mtar cf\x1b[m " + args.backup + " \x1b[1m-C\x1b[m " +
              "\x1b[3m" + tgtdir + "\x1b[m", end="")

        if not args.simulate:
            import tarfile
            tar = tarfile.open(args.backup, 'w')

        for tgtfile in overwritten_tgtfiles:
            shortname = os.path.relpath(tgtfile, tgtdir)
            print(" " + shortname, end="")
            if not args.simulate:
                tar.add(tgtfile)

        if not args.simulate:
            tar.close()

        print("")

    # do installation
    # create directories
    for tgtfile in mkdirlist:
        print("\x1b[1mmkdir\x1b[m \x1b[3m" + tgtfile + "\x1b[m")
        if not args.simulate:
            os.mkdir(tgtfile)

    # install files
    for srcfile, tgtfile, exists, _ in installlist:
        if exists:
            print("\x1b[1mrm\x1b[m " + tgtfile)
            if not args.simulate:
                os.unlink(tgtfile)

        if args.symlink:
            print("\x1b[1mln -s\x1b[m " + srcfile + " " + tgtfile)
            if not args.simulate:
                os.symlink(srcfile, tgtfile)
        elif args.hardlink:
            print("\x1b[1mln\x1b[m " + srcfile + " " + tgtfile)
            if not args.simulate:
                os.link(srcfile, tgtfile)
        else:
            print("\x1b[1mcp\x1b[m " + srcfile + " " + tgtfile)
            if not args.simulate:
                data = open(srcfile, "rb").read()
                open(tgtfile, "wb").write(data)

            if os.stat(srcfile).st_mode & (64 + 8 + 1):
                #set x flag
                print("\x1b[1mchmod +x\x1b[m " + tgtfile)
                if not args.simulate:
                    os.chmod(tgtfile, os.stat(tgtfile).st_mode | (64 + 8 + 1))

if __name__ == "__main__":
    try:
        main()
    except InstException as e:
        print(e)
    except KeyboardInterrupt:
        print("\nInterrupted by user")
